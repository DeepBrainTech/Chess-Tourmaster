<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chess Tourmaster</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Parse hash parameters (#token=...&locale=...)
        function getHashParams() {
            const hash = window.location.hash.substring(1);
            const params = {};
            hash.split('&').forEach(part => {
                const [key, value] = part.split('=');
                params[key] = decodeURIComponent(value);
            });
            return params;
        }

        // Extract token
        const params = getHashParams();
        const jwtToken = params.token;

        if (!jwtToken) {
            // NOTE: Replaced alert with console message/dummy logic for deployment safety.
            console.log("No token provided. Running in default mode.");
        }
        // -----------------------------
        // Decode the JWT payload
        // -----------------------------
        function decodeJwt(token) {
            try {
                const payload = token.split('.')[1];
                const base64 = payload.replace(/-/g, '+').replace(/_/g, '/');
                const json = decodeURIComponent(atob(base64).split('').map(c =>
                    '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
                ).join(''));

                return JSON.parse(json);
            } catch (err) {
                console.error("Error decoding JWT:", err);
                return null;
            }
        }

        const userData = decodeJwt(jwtToken);

        console.log("Decoded Token: ", userData);

        // -----------------------------
        // Extract user data
        // -----------------------------
        let USER_ID = null;
        let USERNAME = "Guest";

        if (userData) {
            USER_ID = userData.user_id;
            USERNAME = userData.username;
        }

        console.log("User ID:", USER_ID);
        console.log("Username:", USERNAME);
        function saveProgress(progressObj) {
            if (!USER_ID) return;
            const key = `tourmaster_progress_${USER_ID}`;
            // Save the high score, which represents the highest cumulative *base* score achieved
            localStorage.setItem(key, JSON.stringify({ highScore: progressObj.highScore }));
            console.log("Progress saved:", progressObj);
        }

        function loadProgress() {
            if (!USER_ID) return null;
            const key = `tourmaster_progress_${USER_ID}`;
            const raw = localStorage.getItem(key);
            if (!raw) return null;

            try {
                const data = JSON.parse(raw);
                console.log("Loaded progress:", data);
                // Load high score
                return {
                    highScore: data.highScore || 0,
                };
            } catch (e) {
                console.error("Error loading saved progress:", e);
                return null;
            }
        }
    </script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@400;700&display=swap');

        body {
            font-family: 'Lato', sans-serif;
            background-color: #0f172a; /* Default Slate 900 */
            color: #e0e0e0;
            overflow: hidden; /* Prevent scrolling on mobile */
            touch-action: none;
            transition: background 0.5s ease;
        }

        h1, h2, .fantasy-font {
            font-family: 'Cinzel', serif;
        }

        /* Board Styling */
        #game-board {
            /* Wooden/Textured background for the board itself */
            background-image: repeating-linear-gradient(45deg, #1e293b 25%, transparent 25%, transparent 75%, #1e293b 75%, #1e293b), repeating-linear-gradient(45deg, #1e293b 25%, #0f172a 25%, #0f172a 75%, #1e293b 75%, #1e293b);
            background-position: 0 0, 10px 10px;
            background-size: 20px 20px;
            box-shadow: inset 0 0 20px #000;
        }

        .tile {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            aspect-ratio: 1 / 1;
            position: relative;
            /* Explicit borders for clarity */
            border: 1px solid rgba(255, 255, 255, 0.15); 
        }

        /* --- THEME-SPECIFIC BOARD STYLING --- */

        /* Cosmic Theme (Default) */
        .bg-theme-cosmic #game-board {
            background-image: repeating-linear-gradient(45deg, #1e293b 25%, transparent 25%, transparent 75%, #1e293b 75%, #1e293b), repeating-linear-gradient(45deg, #1e293b 25%, #0f172a 25%, #0f172a 75%, #1e293b 75%, #1e293b);
        }
        .bg-theme-cosmic .tile:not(.visited):not(.king-tile) {
            background-color: #334155; /* Slate 700 */
        }
        .bg-theme-cosmic .tile:not(.visited):not(.king-tile):hover {
            background-color: #475569; /* Slate 600 */
        }

        /* Royal Theme Board */
        .bg-theme-royal #game-board {
            background-image: repeating-linear-gradient(45deg, #37004d 25%, transparent 25%, transparent 75%, #37004d 75%, #37004d), repeating-linear-gradient(45deg, #37004d 25%, #1c0029 25%, #1c0029 75%, #37004d 75%, #37004d);
        }
        .bg-theme-royal .tile:not(.visited):not(.king-tile) {
            background-color: #4a044e; /* Purple 900 */
            border-color: #6d28d9;
        }
        .bg-theme-royal .tile:not(.visited):not(.king-tile):hover {
            background-color: #6b21a8; /* Purple 800 */
        }

        /* Nature Theme Board */
        .bg-theme-nature #game-board {
            background-image: repeating-linear-gradient(45deg, #14532d 25%, transparent 25%, transparent 75%, #14532d 75%, #14532d), repeating-linear-gradient(45deg, #14532d 25%, #047857 25%, #047857 75%, #14532d 75%, #14532d);
        }
        .bg-theme-nature .tile:not(.visited):not(.king-tile) {
            background-color: #065f46; /* Emerald 700 */
            border-color: #10b981;
        }
        .bg-theme-nature .tile:not(.visited):not(.king-tile):hover {
            background-color: #059669; /* Emerald 600 */
        }

        /* Inferno Theme Board */
        .bg-theme-inferno #game-board {
            background-image: repeating-linear-gradient(45deg, #7f1d1d 25%, transparent 25%, transparent 75%, #7f1d1d 75%, #7f1d1d), repeating-linear-gradient(45deg, #7f1d1d 25%, #450a0a 25%, #450a0a 75%, #7f1d1d 75%, #7f1d1d);
        }
        .bg-theme-inferno .tile:not(.visited):not(.king-tile) {
            background-color: #b91c1c; /* Red 700 */
            border-color: #f87171;
        }
        .bg-theme-inferno .tile:not(.visited):not(.king-tile):hover {
            background-color: #dc2626; /* Red 600 */
        }
        
        /* New: Desert Theme Board */
        .bg-theme-desert #game-board {
            background-image: repeating-linear-gradient(45deg, #78350f 25%, transparent 25%, transparent 75%, #78350f 75%, #78350f), repeating-linear-gradient(45deg, #78350f 25%, #4a2107 25%, #4a2107 75%, #78350f 75%, #78350f);
        }
        .bg-theme-desert .tile:not(.visited):not(.king-tile) {
            background-color: #92400e; /* Amber 800 */
            border-color: #fbbf24;
        }
        .bg-theme-desert .tile:not(.visited):not(.king-tile):hover {
            background-color: #b45309; /* Amber 700 */
        }
        
        /* New: Frost Theme Board */
        .bg-theme-frost #game-board {
            background-image: repeating-linear-gradient(45deg, #1e3a8a 25%, transparent 25%, transparent 75%, #1e3a8a 75%, #1e3a8a), repeating-linear-gradient(45deg, #1e3a8a 25%, #3b82f6 25%, #3b82f6 75%, #1e3a8a 75%, #1e3a8a);
        }
        .bg-theme-frost .tile:not(.visited):not(.king-tile) {
            background-color: #60a5fa; /* Blue 400 */
            border-color: #eff6ff;
        }
        .bg-theme-frost .tile:not(.visited):not(.king-tile):hover {
            background-color: #3b82f6; /* Blue 500 */
        }
        
        /* New: Volcanic Theme Board */
        .bg-theme-volcanic #game-board {
            background-image: repeating-linear-gradient(45deg, #3f3f46 25%, transparent 25%, transparent 75%, #3f3f46 75%, #3f3f46), repeating-linear-gradient(45deg, #3f3f46 25%, #18181b 25%, #18181b 75%, #3f3f46 75%, #3f3f46);
        }
        .bg-theme-volcanic .tile:not(.visited):not(.king-tile) {
            background-color: #52525b; /* Zinc 600 */
            border-color: #a1a1aa;
        }
        .bg-theme-volcanic .tile:not(.visited):not(.king-tile):hover {
            background-color: #3f3f46; /* Zinc 700 */
        }
        /* --- END THEME-SPECIFIC BOARD STYLING --- */


        .tile.visited {
            background-color: #020617 !important; /* Slate 950 */
            border-color: #1e293b !important;
            box-shadow: inset 0 0 15px #000;
            transform: scale(0.92);
            opacity: 0.6;
        }

        .tile.valid-move {
            background-color: rgba(34, 197, 94, 0.15); /* Green tint */
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.3), inset 0 0 10px rgba(34, 197, 94, 0.1);
            border-color: #4ade80;
            cursor: pointer;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.4); }
            70% { transform: scale(1.03); box-shadow: 0 0 0 8px rgba(74, 222, 128, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
        }

        /* Fire Effect */
        .fire-anim {
            animation: burn 0.6s infinite alternate ease-in-out;
            filter: drop-shadow(0 0 8px #f97316);
        }
        @keyframes burn {
            from { transform: scale(1) translateY(0); filter: drop-shadow(0 0 5px #f97316); }
            to { transform: scale(1.15) translateY(-2px); filter: drop-shadow(0 0 12px #ea580c); }
        }

        /* Knight Animation */
        .knight-piece {
            animation: bounce 2s infinite ease-in-out;
            filter: drop-shadow(0 0 10px cyan);
            position: relative; 
            z-index: 50;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-12px); }
        }

        /* Enemy King Animation */
        .king-piece {
            animation: floatKing 3s infinite ease-in-out;
            filter: drop-shadow(0 0 15px #e11d48);
            position: relative;
            z-index: 40;
        }
        @keyframes floatKing {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-6px) scale(1.1); }
        }
        .king-tile {
            border-color: #e11d48 !important; /* Rose 600 */
            box-shadow: 0 0 20px rgba(225, 29, 72, 0.3);
            background-color: #3f1018 !important; /* Dark Red BG */
        }
        
        /* Quest Tile Value Styling */
        .quest-value {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 0.75rem; /* text-xs */
            font-weight: bold;
            color: #fcd34d; /* Amber 300 */
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            transition: transform 0.2s;
        }
        .valid-move .quest-value {
            transform: scale(1.1);
            color: #4ade80; /* Green highlight */
        }

        /* Star Animation */
        .star-pop {
            animation: starPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) backwards;
        }
        @keyframes starPop {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Modal Backdrop */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
        }

        /* Shake animation for errors */
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        
        /* Progress Bar for Fire */
        .fire-timer-bar {
            transition: width 0.1s linear;
        }

        /* Background Themes */
        .bg-theme-cosmic {
            background: radial-gradient(circle at center, #1e1b4b 0%, #020617 100%);
        }
        .bg-theme-royal {
            background: linear-gradient(135deg, #4a044e 0%, #2e1065 100%);
        }
        .bg-theme-nature {
            background: linear-gradient(to bottom, #064e3b 0%, #022c22 100%);
        }
        .bg-theme-inferno {
            background: radial-gradient(circle at bottom, #7f1d1d 0%, #450a0a 100%);
        }
        
        /* New Background Themes */
        .bg-theme-desert {
            background: linear-gradient(to top, #92400e 0%, #4a2107 100%);
        }
        .bg-theme-frost {
            background: linear-gradient(to top, #60a5fa 0%, #1e3a8a 100%);
        }
        .bg-theme-volcanic {
            background: radial-gradient(circle at center, #3f3f46 0%, #18181b 100%);
        }

        .theme-blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.3;
            animation: blobFloat 10s infinite alternate;
        }
        @keyframes blobFloat {
            0% { transform: translate(0, 0) scale(1); }
            100% { transform: translate(20px, -20px) scale(1.1); }
        }
    </style>
</head>
<body id="main-body" class="h-screen w-screen flex flex-col items-center justify-center relative overflow-hidden bg-theme-cosmic">

    <div id="player-info" style="position:absolute; top:10px; left:10px; color:white; font-size:18px;"></div>

    <div id="bg-blobs" class="absolute inset-0 z-0 pointer-events-none overflow-hidden">
        <div class="theme-blob w-96 h-96 bg-cyan-500 top-0 left-0"></div>
        <div class="theme-blob w-96 h-96 bg-purple-500 bottom-0 right-0 animation-delay-2000"></div>
    </div>

    <div class="z-10 w-full max-w-2xl px-4 mb-2 flex justify-between items-center">
        <div>
            <h1 class="text-xl md:text-3xl text-rose-500 font-bold fantasy-font tracking-wider shadow-black drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)]">
                <i class="fas fa-chess-board mr-2"></i>Tourmaster
            </h1>
            <div class="flex items-center gap-3 text-sm md:text-base text-gray-300 mt-1">
                <span id="mode-display" class="font-bold text-white">Classic Tour</span>
                <span class="text-gray-500">|</span>
                <span>Lvl <span id="level-display" class="font-bold text-white">1</span></span>
                <span class="text-gray-500">|</span>
                <span class="font-mono text-cyan-300"><i class="far fa-clock mr-1"></i><span id="game-timer">00:00</span></span>
            </div>
        </div>
        <div class="flex gap-2">
            <button onclick="game.showModeSelection(true)" class="bg-indigo-700/80 hover:bg-indigo-600 text-white p-2 rounded-lg shadow-lg border border-indigo-500" title="Change Mode">
                <i class="fas fa-gamepad"></i>
            </button>
            <button onclick="game.undo()" class="bg-slate-700/80 hover:bg-slate-600 text-white p-2 rounded-lg shadow-lg border border-slate-500" title="Undo">
                <i class="fas fa-undo"></i>
            </button>
            <button onclick="game.restartLevel()" class="bg-slate-700/80 hover:bg-slate-600 text-white p-2 rounded-lg shadow-lg border border-slate-500" title="Restart">
                <i class="fas fa-redo"></i>
            </button>
            <button onclick="game.toggleSettings()" class="bg-indigo-700/80 hover:bg-indigo-600 text-white p-2 rounded-lg shadow-lg border border-indigo-500" title="Settings">
                <i class="fas fa-cog"></i>
            </button>
            <button onclick="toggleHelp()" class="bg-rose-700/80 hover:bg-rose-600 text-white p-2 rounded-lg shadow-lg border border-rose-500" title="Help">
                <i class="fas fa-question"></i>
            </button>
        </div>
    </div>

    <div class="z-10 w-full max-w-2xl px-4 mb-2 flex flex-wrap justify-between items-center h-8">
        <div class="text-cyan-300 font-bold text-sm md:text-lg flex items-center bg-slate-900/50 px-3 py-1 rounded-full border border-slate-700">
            Tiles Left: <span id="tiles-left" class="ml-2 text-white">0</span>
        </div>
        
        <div id="quest-score-container" class="hidden text-amber-300 font-bold text-sm md:text-lg flex items-center bg-slate-900/50 px-3 py-1 rounded-full border border-slate-700">
            Score: <span id="current-score" class="ml-1 text-white">0</span> / <span id="required-score" class="text-white">0</span>
        </div>

        <div id="fire-timer-container" class="hidden flex items-center gap-2 text-orange-500 bg-black/60 px-3 py-1 rounded-full border border-orange-900/50">
            <i class="fas fa-fire animate-pulse"></i>
            <div class="w-24 h-3 bg-gray-800 rounded-full overflow-hidden border border-orange-900 shadow-inner">
                <div id="fire-bar" class="h-full bg-gradient-to-r from-yellow-500 via-orange-500 to-red-600 w-full fire-timer-bar"></div>
            </div>
        </div>
    </div>

    <div class="z-10 relative bg-slate-800/60 p-2 md:p-3 rounded-xl shadow-2xl border-4 border-slate-600 backdrop-blur-md w-full max-w-[95vw] md:max-w-2xl aspect-square flex items-center justify-center mx-auto">
        <div id="game-board" class="grid gap-1 bg-slate-900 p-2 rounded-lg select-none w-full h-full">
            </div>
        
        <div id="message-overlay" class="absolute inset-0 flex items-center justify-center pointer-events-none opacity-0 transition-opacity duration-300 z-50">
            <h2 class="text-4xl md:text-6xl font-bold text-white drop-shadow-[0_4px_4px_rgba(0,0,0,0.9)] fantasy-font transform scale-150 transition-transform duration-300 text-center px-4" id="message-text"></h2>
        </div>
    </div>

    <div class="z-10 mt-4 text-center text-gray-400 text-xs">
        <p id="footer-goal">Goal: Clear board &rarr; Capture <span class="text-rose-500 font-bold">King</span></p>
    </div>

    <div id="main-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
        <div class="bg-gray-800 border-2 border-rose-600 p-6 md:p-8 rounded-2xl shadow-2xl max-w-sm w-full text-center m-4 relative">
            <div class="mb-4 text-6xl flex justify-center gap-4" id="modal-icon"></div>
            <h2 id="modal-title" class="text-3xl font-bold text-white mb-2 fantasy-font"></h2>
            <div id="modal-body" class="text-gray-300 mb-6 text-sm"></div>
            <div id="high-score-display" class="text-lg font-mono text-yellow-300 mb-4 fantasy-font hidden"></div> 
            <button id="modal-btn" class="w-full bg-gradient-to-r from-rose-600 to-rose-700 hover:from-rose-500 text-white font-bold py-3 rounded-xl shadow-lg transition transform hover:scale-105">
                Action
            </button>
        </div>
    </div>

    <div id="settings-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden" onclick="game.toggleSettings()">
        <div class="bg-gray-800 border-2 border-indigo-500 p-6 rounded-2xl shadow-2xl max-w-xs w-full m-4" onclick="event.stopPropagation()">
            <h3 class="text-xl font-bold text-indigo-400 mb-4 fantasy-font text-center">Select Theme</h3>
            <div class="grid grid-cols-2 gap-3">
                <button onclick="game.setTheme('cosmic')" class="p-3 rounded-lg bg-indigo-900 border border-indigo-700 hover:bg-indigo-800 text-white text-sm">Cosmic</button>
                <button onclick="game.setTheme('royal')" class="p-3 rounded-lg bg-purple-900 border border-purple-700 hover:bg-purple-800 text-white text-sm">Royal</button>
                <button onclick="game.setTheme('nature')" class="p-3 rounded-lg bg-emerald-900 border border-emerald-700 hover:bg-emerald-800 text-white text-sm">Nature</button>
                <button onclick="game.setTheme('inferno')" class="p-3 rounded-lg bg-red-900 border border-red-700 hover:bg-red-800 text-white text-sm">Inferno</button>
                <!-- NEW THEME BUTTONS -->
                <button onclick="game.setTheme('desert')" class="p-3 rounded-lg bg-yellow-800 border border-yellow-600 hover:bg-yellow-700 text-white text-sm">Desert</button>
                <button onclick="game.setTheme('frost')" class="p-3 rounded-lg bg-blue-700 border border-blue-500 hover:bg-blue-600 text-white text-sm">Frost</button>
                <button onclick="game.setTheme('volcanic')" class="p-3 rounded-lg bg-zinc-700 border border-zinc-500 hover:bg-zinc-600 text-white text-sm">Volcanic</button>
            </div>
            <button onclick="game.toggleSettings()" class="mt-6 w-full bg-slate-700 text-white py-2 rounded-lg hover:bg-slate-600 text-sm">Close</button>
        </div>
    </div>

    <div id="help-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden" onclick="toggleHelp()">
        <div class="bg-slate-800 border-2 border-slate-500 p-6 rounded-2xl shadow-2xl max-w-sm w-full m-4" onclick="event.stopPropagation()">
            <h3 class="text-2xl font-bold text-rose-500 mb-4 fantasy-font border-b border-slate-600 pb-2" id="help-modal-title">Instructions (Classic Tour)</h3>
            <ul id="help-modal-body" class="text-left text-gray-300 space-y-3 text-sm">
                </ul>
            <button onclick="toggleHelp()" class="mt-6 w-full bg-slate-700 text-white py-2 rounded-lg">Close</button>
        </div>
    </div>

    <script>
        document.getElementById("player-info").innerText = `Player: ${USERNAME}`;
        
        // --- Sound Manager ---
        const sound = {
            ctx: null,
            init() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playTone(freq, type, duration, vol=0.1) {
                if (!this.ctx) this.init();
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playMove() {
                this.playTone(300, 'sine', 0.15, 0.2);
                setTimeout(() => this.playTone(100, 'square', 0.2, 0.1), 100); 
            },
            playCollect() {
                this.playTone(880, 'sine', 0.08, 0.2);
            },
            playVictory() {
                if (!this.ctx) this.init();
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const now = this.ctx.currentTime;
                [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 'triangle', 0.4, 0.2), i * 150);
                });
            },
            playBurn() {
                this.speak("You are cooked");
                this.playTone(100, 'sawtooth', 0.5, 0.2);
            },
            speak(text) {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    const msg = new SpeechSynthesisUtterance(text);
                    msg.rate = 1.2; 
                    msg.pitch = 1.0;
                    window.speechSynthesis.speak(msg);
                }
            }
        };

        // --- Game Config & State ---
        const CONFIG = {
            gridSize: 5, 
            maxLevel: 10,
            fireTimeLimit: 3000, 
            fireChance: 0.15,
        };

        const STATE = {
            level: 1,
            grid: [], 
            knightPos: { r: 0, c: 0 },
            kingPos: { r: 0, c: 0 },
            history: [], 
            tilesLeft: 0,
            parTime: 10, 
            isPlaying: false,
            fireTimer: null,
            fireStartTime: 0,
            lastFireSecond: 4, 
            gridSizeVal: 5,
            gameStartTime: 0,
            gameTimeInterval: null,
            gameMode: 'classic', 
            currentScore: 0, // Math Tour score for CURRENT LEVEL
            requiredScore: 0,
            tileValues: [],
            scoreMultiplier: 1, 
            
            // NEW: Stores the board configuration for level retries
            savedGridConfig: null, 
            
            // --- UPDATED SCORING VARIABLES ---
            currentRunScore: 0,        // Total score for the current streak run (resets on loss)
            cumulativeBaseScore: 0,    // Total score accumulated from level bonuses only (persists across retries)
            highScore: 0,              // Highest cumulativeBaseScore ever achieved
            streak: 0,                 // Consecutive level completion streak (resets on loss)
        };

        const ICONS = {
            knight: '<i class="fas fa-chess-knight knight-piece text-3xl sm:text-4xl md:text-5xl lg:text-6xl text-cyan-400"></i>',
            king: '<i class="fas fa-chess-king king-piece text-2xl sm:text-3xl md:text-4xl lg:text-5xl text-rose-500"></i>',
            fire: '<i class="fas fa-fire text-2xl sm:text-3xl md:text-4xl lg:text-5xl text-orange-500 fire-anim opacity-90"></i>',
        };

        const THEMES = {
            cosmic: 'bg-theme-cosmic',
            royal: 'bg-theme-royal',
            nature: 'bg-theme-nature',
            inferno: 'bg-theme-inferno',
            desert: 'bg-theme-desert',
            frost: 'bg-theme-frost',
            volcanic: 'bg-theme-volcanic'
        };

        const game = {
            init() {
                this.bindEvents();
                this.loadGlobalScore(); 
                this.showModeSelection();
            },

            loadGlobalScore() { 
                const progress = loadProgress();
                if (progress && progress.highScore) {
                    STATE.highScore = progress.highScore;
                }
                // Reset session scores for a new application load
                STATE.currentRunScore = 0; 
                STATE.cumulativeBaseScore = 0; 
                STATE.streak = 0;
            },

            bindEvents() {
                document.getElementById('modal-btn').addEventListener('click', () => {
                    if (!sound.ctx) sound.init();
                    
                    const type = document.getElementById('modal-btn').dataset.action;
                    if (type === 'next') this.nextLevel();
                    else if (type === 'retry') this.restartLevel();
                    else this.startLevel(1);
                    this.hideModal();
                });
            },
            
            // --- Mode Selection & Setup ---
            showModeSelection(isChanging=false) {
                if (isChanging) this.stopGameTimer(); 
                STATE.isPlaying = false;
                
                const modal = document.getElementById('main-modal');
                const icon = document.getElementById('modal-icon');
                const title = document.getElementById('modal-title');
                const body = document.getElementById('modal-body');
                const btn = document.getElementById('modal-btn');
                const highScoreDisplay = document.getElementById('high-score-display'); 

                modal.classList.remove('hidden');
                btn.classList.add('hidden');
                highScoreDisplay.classList.add('hidden'); 

                icon.innerHTML = '<i class="fas fa-chess-knight text-cyan-500"></i><i class="fas fa-chess-king text-rose-500"></i>';
                title.innerText = "Chess Tourmaster";
                body.innerHTML = `
                    <p class="text-sm text-gray-400 mb-4">${isChanging ? 'Game paused. Select a new mode to start over:' : 'Select your game mode:'}</p>
                    <div class="space-y-3">
                        <button onclick="game.setGameMode('classic')" class="w-full bg-slate-700 hover:bg-slate-600 text-white font-bold py-3 rounded-xl transition">
                            Classic Tour
                        </button>
                        <button onclick="game.setGameMode('math_tour')" class="w-full bg-rose-600 hover:bg-rose-500 text-white font-bold py-3 rounded-xl transition">
                            Math Tour
                        </button>
                    </div>
                `;
            },
            
            setGameMode(mode) {
                STATE.gameMode = mode;
                STATE.level = 1;
                STATE.scoreMultiplier = 1; 
                
                // Reset all scores and streak for a new run
                STATE.currentRunScore = 0;
                STATE.cumulativeBaseScore = 0; 
                STATE.streak = 0; 
                STATE.savedGridConfig = null; // Clear saved state on mode change
                
                document.getElementById('main-modal').classList.add('hidden');
                
                this.updateUI(); 
                this.updateUIModeVisibility();
                this.updateHelpModal();
                this.showModal('welcome');
            },
            
            updateUIModeVisibility() {
                const isMathTour = STATE.gameMode === 'math_tour';
                // Toggle Score Bar
                const scoreContainer = document.getElementById('quest-score-container');
                isMathTour ? scoreContainer.classList.remove('hidden') : scoreContainer.classList.add('hidden');
                
                // Update Mode Display
                document.getElementById('mode-display').innerText = isMathTour ? 'Math Tour' : 'Classic Tour';
                
                // Update Footer Goal
                document.getElementById('footer-goal').innerHTML = isMathTour 
                    ? 'Goal: Collect score &rarr; Capture <span class="text-rose-500 font-bold">King</span>' // MODIFIED
                    : 'Goal: Clear board &rarr; Capture <span class="text-rose-500 font-bold">King</span>';
            },

            // NEW: Private helper to handle the common state setup after generation/load
            _startLevelProcess(config) {
                STATE.level = config.level;
                // Use a deep copy of the grid for the current game session
                STATE.grid = config.grid.map(row => row.map(tile => ({ ...tile }))); 
                STATE.knightPos = { ...config.knightPos };
                STATE.kingPos = { ...config.kingPos };
                STATE.gridSizeVal = config.gridSizeVal;
                
                STATE.tilesLeft = config.tilesLeft;
                STATE.parTime = config.parTime;

                // Reset transient state for the current run
                STATE.currentScore = config.initialScore || 0; 
                STATE.requiredScore = config.requiredScore;
                STATE.scoreMultiplier = 1; // Always reset multiplier on restart
                STATE.history = [];
                
                // Start the game loop
                STATE.isPlaying = true;
                this.stopFireTimer();
                this.startGameTimer(); 
                this.renderBoard();
                this.updateUI();
                this.checkFireLogic();
            },

            // NEW: Generates the entire board configuration and returns it (does not modify STATE)
            _generateLevelConfig(levelNum) {
                const config = { level: levelNum };

                config.gridSizeVal = levelNum > 5 ? 6 : 5;
                if (levelNum > 8) config.gridSizeVal = 7;
                
                const size = config.gridSizeVal;
                config.grid = Array(size).fill().map(() => Array(size).fill(null));

                let maxPathLength = size * size; 
                if (levelNum === 1) maxPathLength = 5;      
                else if (levelNum === 2) maxPathLength = 8; 
                else if (levelNum === 3) maxPathLength = 12; 
                else if (levelNum === 4) maxPathLength = 18; 
                
                let cr = Math.floor(Math.random() * size);
                let cc = Math.floor(Math.random() * size);
                config.kingPos = { r: cr, c: cc };

                let genGrid = Array(size).fill().map(() => Array(size).fill(0));
                let path = [{r: cr, c: cc}];
                genGrid[cr][cc] = 1;

                let curr = {r: cr, c: cc};
                let attempts = 1000;
                
                while (path.length < maxPathLength && attempts > 0) {
                    let moves = this.getValidMoves(curr.r, curr.c, size);
                    let validNext = moves.filter(m => genGrid[m.r][m.c] === 0);
                    if (validNext.length === 0) break;
                    let next = validNext[Math.floor(Math.random() * validNext.length)];
                    genGrid[next.r][next.c] = 1;
                    path.push(next);
                    curr = next;
                    attempts--;
                }
                if (path.length < maxPathLength) {
                    curr = path[Math.floor(Math.random() * path.length)];
                    attempts = 1000;
                    while (path.length < maxPathLength && attempts > 0) {
                        let moves = this.getValidMoves(curr.r, curr.c, size);
                        let validNext = moves.filter(m => genGrid[m.r][m.c] === 0);
                        if (validNext.length === 0) {
                            curr = path[Math.floor(Math.random() * path.length)];
                            attempts--;
                            continue;
                        }
                        let next = validNext[Math.floor(Math.random() * validNext.length)];
                        genGrid[next.r][next.c] = 1;
                        path.push(next);
                        curr = next;
                        attempts--;
                    }
                }
                
                config.knightPos = { ...curr };
                
                const isMathTour = STATE.gameMode === 'math_tour';
                let maxPossibleBaseScore = 0;
                let tilesToVisit = 0;

                for(let r=0; r<size; r++) {
                    for(let c=0; c<size; c++) {
                        let type = 'empty';
                        if (r === config.kingPos.r && c === config.kingPos.c) type = 'king';
                        else if (genGrid[r][c] === 0) type = 'void';
                        
                        let hasFire = false;
                        let isPath = genGrid[r][c] === 1;
                        let isStart = (r === config.knightPos.r && c === config.knightPos.c);
                        let isKing = (r === config.kingPos.r && c === config.kingPos.c);
                        let value = 0;

                        if (isPath && !isStart && !isKing) {
                            tilesToVisit++;
                            if (Math.random() < (0.05 + (levelNum * 0.02))) hasFire = true;
                            if (isMathTour) {
                                value = Math.floor(Math.random() * 4) + 2; 
                                maxPossibleBaseScore += value; 
                            }
                        }

                        config.grid[r][c] = { 
                            type: type, 
                            hasFire: hasFire, 
                            // Mark starting position as visited in the config for accurate tile count/score calculation
                            visited: (r === config.knightPos.r && c === config.knightPos.c), 
                            r: r, 
                            c: c,
                            value: value,
                        };
                    }
                }
                
                // Final Config adjustments
                config.tilesLeft = tilesToVisit;
                config.parTime = Math.max(5, tilesToVisit * 2.5);
                config.initialScore = 0;
                config.requiredScore = 0;

                if (isMathTour) {
                    const numPointTiles = tilesToVisit; 
                    let requiredScoreMultiplier = 4;
    
                    if (levelNum === 1) {
                        requiredScoreMultiplier = 2; 
                    }

                    let targetRequiredScore = Math.ceil(numPointTiles * requiredScoreMultiplier);
                    
                    config.requiredScore = Math.min(targetRequiredScore, maxPossibleBaseScore);
                    config.requiredScore = Math.max(1, config.requiredScore);
                    
                    // Apply initial score/value change to starting tile
                    config.initialScore += config.grid[config.knightPos.r][config.knightPos.c].value;
                    config.grid[config.knightPos.r][config.knightPos.c].value = 0; 
                }

                config.grid[config.kingPos.r][config.kingPos.c].type = 'king';
                config.grid[config.kingPos.r][config.kingPos.c].hasFire = false;
                
                return config;
            },

            // MODIFIED: Accepts an optional flag to use the saved state
            startLevel(lvl, useSaved = false) {
                let config;
                
                if (useSaved && STATE.savedGridConfig && STATE.savedGridConfig.level === lvl) {
                    // Use saved config for retry
                    config = STATE.savedGridConfig;
                } else {
                    // Start new level: generate config and save it
                    if (lvl === 1) {
                        STATE.currentRunScore = 0;
                        STATE.cumulativeBaseScore = 0; 
                        STATE.streak = 0;
                        STATE.savedGridConfig = null; // Ensure fresh start
                    }
                    config = this._generateLevelConfig(lvl);
                    // Save a deep copy of the generated config for future retries
                    STATE.savedGridConfig = JSON.parse(JSON.stringify(config)); 
                }
                
                this._startLevelProcess(config);
                document.getElementById('level-display').innerText = lvl;
            },
            
            // MODIFIED: Now calls startLevel with the useSaved=true flag
            nextLevel() { 
                STATE.savedGridConfig = null; // Clear saved config for the NEW level
                this.startLevel(STATE.level + 1); 
            },

            restartLevel() { 
                // Don't touch STATE.cumulativeBaseScore on a retry
                // Reset streak and current run score for a retry
                STATE.currentRunScore = STATE.cumulativeBaseScore; // Start with accumulated base score
                STATE.streak = 0; // Streak restarts on a retry
                // KEY CHANGE: Pass 'true' to use the saved config
                this.startLevel(STATE.level, true); 
            },

            getValidMoves(r, c, size) {
                const moves = [
                    {r: r-2, c: c-1}, {r: r-2, c: c+1},
                    {r: r-1, c: c-2}, {r: r-1, c: c+2},
                    {r: r+1, c: c-2}, {r: r+1, c: c+2},
                    {r: r+2, c: c-1}, {r: r+2, c: c+1}
                ];
                return moves.filter(m => m.r >= 0 && m.r < size && m.c >= 0 && m.c < size);
            },

            handleMove(r, c) {
                if (!STATE.isPlaying) return;

                const curr = STATE.knightPos;
                const dr = Math.abs(curr.r - r);
                const dc = Math.abs(curr.c - c);
                
                if (!((dr === 2 && dc === 1) || (dr === 1 && dc === 2))) {
                    this.triggerShake(); return;
                }

                const targetTile = STATE.grid[r][c];
                const isMathTour = STATE.gameMode === 'math_tour';

                if (targetTile.type === 'void' || targetTile.visited) {
                    this.triggerShake(); return;
                }

                if (targetTile.type === 'king') {
                    const hasClearedTiles = STATE.tilesLeft === 0;

                    // Classic Tour check: Must clear all tiles before capturing King
                    if (STATE.gameMode === 'classic' && !hasClearedTiles) { // MODIFIED CHECK
                        this.showMessage("Guards remain!", "text-rose-400");
                        this.triggerShake();
                        return;
                    } 
                    
                    if (isMathTour) {
                        const hasEnoughScore = STATE.currentScore >= STATE.requiredScore;
                        if (!hasEnoughScore) {
                            this.showMessage(`Need ${STATE.requiredScore - STATE.currentScore} more score!`, "text-amber-400");
                            this.triggerShake();
                            return;
                        }
                    }
                    
                    this.winGame();
                    return;
                }

                sound.playMove(); 
                
                const collectedValue = targetTile.value; 
                let finalScore = 0;
                
                const multiplierUsed = STATE.scoreMultiplier; 
                let multiplierAfterMove = 1;

                if (isMathTour) {
                    finalScore = collectedValue * multiplierUsed; 
                    
                    if (targetTile.hasFire) {
                        multiplierAfterMove = 2; 
                        this.showMessage("x2 Score Multiplier Active!", "text-orange-400");
                    } else {
                        multiplierAfterMove = 1; 
                    }
                }

                STATE.history.push({ 
                    knightPos: { ...curr }, 
                    prevPos: { r, c },
                    scoreCollected: finalScore, 
                    valueRestored: collectedValue, 
                    multiplierUsed: multiplierUsed,
                });

                this.stopFireTimer();
                STATE.knightPos = { r, c };
                targetTile.visited = true;
                
                if (isMathTour) {
                    STATE.currentScore += finalScore;
                    targetTile.value = 0; 
                    STATE.scoreMultiplier = multiplierAfterMove;

                    if (finalScore > 0) sound.playCollect();
                }

                STATE.tilesLeft--;

                this.renderBoard();
                this.updateUI();
                this.checkFireLogic();
                this.checkStuck();
            },

            undo() {
                if (!STATE.isPlaying || STATE.history.length === 0) return;
                const lastState = STATE.history.pop();
                STATE.knightPos = lastState.knightPos;
                const tile = STATE.grid[lastState.prevPos.r][lastState.prevPos.c];
                
                if (STATE.gameMode === 'math_tour') {
                    tile.value = lastState.valueRestored;
                    STATE.currentScore -= lastState.scoreCollected;
                    STATE.scoreMultiplier = lastState.multiplierUsed; 
                }

                tile.visited = false; 
                STATE.tilesLeft++;
                this.stopFireTimer();
                this.renderBoard();
                this.updateUI();
                this.checkFireLogic();
            },

            startGameTimer() {
                if(STATE.gameTimeInterval) clearInterval(STATE.gameTimeInterval);
                STATE.gameStartTime = Date.now();
                const timerEl = document.getElementById('game-timer');
                
                STATE.gameTimeInterval = setInterval(() => {
                    if(!STATE.isPlaying) return;
                    const diff = Math.floor((Date.now() - STATE.gameStartTime) / 1000);
                    const m = Math.floor(diff / 60).toString().padStart(2, '0');
                    const s = (diff % 60).toString().padStart(2, '0');
                    timerEl.innerText = `${m}:${s}`;
                }, 1000);
                document.getElementById('game-timer').innerText = "00:00";
            },

            stopGameTimer() {
                if(STATE.gameTimeInterval) clearInterval(STATE.gameTimeInterval);
            },

            checkFireLogic() {
                const r = STATE.knightPos.r;
                const c = STATE.knightPos.c;
                const tile = STATE.grid[r][c];

                if (tile.hasFire) {
                    document.getElementById('fire-timer-container').classList.remove('hidden');
                    STATE.fireStartTime = Date.now();
                    STATE.lastFireSecond = 4;
                    
                    const updateTimer = () => {
                        if (!STATE.isPlaying) return;
                        const elapsed = Date.now() - STATE.fireStartTime;
                        const remaining = CONFIG.fireTimeLimit - elapsed;
                        const pct = Math.max(0, (remaining / CONFIG.fireTimeLimit) * 100);
                        
                        document.getElementById('fire-bar').style.width = pct + "%";

                        const seconds = Math.ceil(remaining / 1000);
                        if (seconds < STATE.lastFireSecond && seconds > 0) {
                            sound.speak(seconds.toString());
                            STATE.lastFireSecond = seconds;
                        }

                        if (remaining <= 0) this.loseGame("Burned by fire!");
                        else STATE.fireTimer = requestAnimationFrame(updateTimer);
                    };
                    STATE.fireTimer = requestAnimationFrame(updateTimer);
                } else {
                    document.getElementById('fire-timer-container').classList.add('hidden');
                    window.speechSynthesis.cancel();
                }
            },

            stopFireTimer() {
                if (STATE.fireTimer) cancelAnimationFrame(STATE.fireTimer);
                document.getElementById('fire-timer-container').classList.add('hidden');
                window.speechSynthesis.cancel(); 
            },

            checkStuck() {
                const isMathTour = STATE.gameMode === 'math_tour';
                // Removed the initial 'isReadyToCapture' check as it's no longer necessary or accurate for Math Tour.
                
                const curr = STATE.knightPos;
                const moves = this.getValidMoves(curr.r, curr.c, STATE.gridSizeVal);
                const canMove = moves.some(m => {
                    const t = STATE.grid[m.r][m.c];
                    if (t.type === 'void' || t.visited) return false;
                    
                    if (t.type === 'king') {
                        const scoreCheck = isMathTour ? (STATE.currentScore >= STATE.requiredScore) : true;
                        
                        // Capture logic: Math Tour only requires score. Classic Tour requires cleared tiles and score.
                        const captureCondition = isMathTour 
                            ? scoreCheck 
                            : (STATE.tilesLeft === 0 && scoreCheck);
                        
                        return captureCondition;
                    }
                    return true;
                });
                
                if (!canMove) setTimeout(() => this.loseGame("Trapped!"), 500);
            },

            toggleSettings() {
                const m = document.getElementById('settings-modal');
                m.classList.toggle('hidden');
            },

            setTheme(themeName) {
                const body = document.getElementById('main-body');
                // The body contains the background theme class
                body.className = body.className.replace(/bg-theme-\w+/, THEMES[themeName]);
                
                // We also need to re-render the board to apply the specific tile/border colors 
                // that are now tied to the body's theme class via CSS selectors.
                this.renderBoard(); 
                
                this.toggleSettings();
            },

            renderBoard() {
                const board = document.getElementById('game-board');
                const size = STATE.gridSizeVal;
                board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
                board.innerHTML = '';
                
                const isMathTour = STATE.gameMode === 'math_tour';
                const hasEnoughScore = isMathTour ? (STATE.currentScore >= STATE.requiredScore) : true;

                // Logic for King tile styling (highlighting when capture is possible)
                const canCaptureStyling = STATE.gameMode === 'math_tour'
                    ? hasEnoughScore
                    : (STATE.tilesLeft === 0 && hasEnoughScore);


                for(let r=0; r<size; r++) {
                    for(let c=0; c<size; c++) {
                        const tileData = STATE.grid[r][c];
                        const el = document.createElement('div');
                        let classes = "tile w-full rounded-lg flex items-center justify-center ";
                        let zIndex = 10; 

                        if (tileData.type === 'void') {
                            classes += "opacity-0 pointer-events-none"; zIndex = 0;
                        } else if (tileData.type === 'king') {
                            classes += "king-tile"; // Board BG will style this
                            
                            if (canCaptureStyling) { // MODIFIED
                                classes += ' valid-move !bg-rose-500/30';
                            }
                        } else {
                            // Removing hardcoded color classes here to rely solely on theme-specific CSS selectors
                            // The CSS now uses .bg-theme-X .tile:not(.visited)
                            classes += "border-slate-600"; 
                        }

                        if (tileData.visited && !(r===STATE.knightPos.r && c===STATE.knightPos.c)) {
                            classes += " visited";
                        }

                        if (STATE.isPlaying) {
                            const dr = Math.abs(STATE.knightPos.r - r);
                            const dc = Math.abs(STATE.knightPos.c - c);
                            const isKnightMove = (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
                            let isDest = false;
                            
                            if (isKnightMove && !tileData.visited && tileData.type !== 'void') {
                                if (tileData.type === 'king') {
                                    // Valid move check for King tile
                                    const captureCondition = STATE.gameMode === 'math_tour' 
                                        ? hasEnoughScore 
                                        : (STATE.tilesLeft === 0 && hasEnoughScore);
                                        
                                    if (captureCondition) isDest = true;
                                } else {
                                    isDest = true;
                                }
                            }
                            if (isDest) classes += " valid-move";
                        }

                        if (r === STATE.knightPos.r && c === STATE.knightPos.c) {
                            zIndex = 30; 
                        }

                        el.className = classes;
                        el.style.zIndex = zIndex; 

                        let content = '';
                        if (isMathTour && tileData.value > 0) {
                            const displayMultiplier = STATE.scoreMultiplier > 1 ? `x${STATE.scoreMultiplier}` : '';
                            content += `<span class="quest-value">+${tileData.value}${displayMultiplier}</span>`;
                        }
                        
                        if (tileData.hasFire) content += ICONS.fire;
                        if (tileData.type === 'king') content += ICONS.king;
                        
                        if (r === STATE.knightPos.r && c === STATE.knightPos.c) {
                            content += `<div class="absolute inset-0 flex items-center justify-center pointer-events-none">${ICONS.knight}</div>`;
                            el.classList.add('border-cyan-500', 'shadow-[0_0_20px_rgba(6,182,212,0.4)]');
                        }

                        el.innerHTML = content;
                        el.onclick = () => this.handleMove(r, c);
                        board.appendChild(el);
                    }
                }
            },

            updateUI() {
                document.getElementById('tiles-left').innerText = STATE.tilesLeft;
                
                if (STATE.gameMode === 'math_tour') {
                    document.getElementById('current-score').innerText = STATE.currentScore;
                    document.getElementById('required-score').innerText = STATE.requiredScore;
                    
                    const scoreContainer = document.getElementById('quest-score-container');
                    if (STATE.currentScore >= STATE.requiredScore) {
                        scoreContainer.classList.remove('text-amber-300');
                        scoreContainer.classList.add('text-lime-400');
                    } else {
                        scoreContainer.classList.add('text-amber-300');
                        scoreContainer.classList.remove('text-lime-400');
                    }
                }
            },

            updateHelpModal() {
                const isMathTour = STATE.gameMode === 'math_tour';
                document.getElementById('help-modal-title').innerText = isMathTour ? "Instructions (Math Tour)" : "Instructions (Classic Tour)";
                const ul = document.getElementById('help-modal-body');
                
                let fireRule = `
                    <li class="flex items-start"><i class="fas fa-fire w-6 text-orange-500 mt-1"></i> 
                    <span><strong>Fire:</strong> 3s to move or burn! (In Math Tour, landing on fire grants x2 score on the next move).</span></li>
                `;
                
                let helpHtml = `
                    <li class="flex items-start"><i class="fas fa-chess-knight w-6 text-cyan-400 mt-1"></i> <span><strong>Move:</strong> L-shape jump to clear tiles.</span></li>
                    ${isMathTour ? '<li class="flex items-start"><i class="fas fa-plus w-6 text-amber-400 mt-1"></i> <span>**Gather:** Collect tile points to meet score requirement for King capture.</span></li>' : ''}
                    ${fireRule}
                    <li class="flex items-start"><i class="fas fa-chess-king w-6 text-rose-500 mt-1"></i> <span><strong>Win:</strong> ${isMathTour ? 'Meet score requirement' : 'Clear board'} to capture King.</span></li>
                `;
                ul.innerHTML = helpHtml;
            },

            triggerShake() {
                const b = document.getElementById('game-board');
                b.classList.remove('shake');
                void b.offsetWidth;
                b.classList.add('shake');
            },

            showMessage(msg, colorClass) {
                const el = document.getElementById('message-overlay');
                const txt = document.getElementById('message-text');
                txt.innerText = msg;
                txt.className = `text-4xl md:text-6xl font-bold drop-shadow-md fantasy-font transform scale-150 transition-transform duration-300 ${colorClass}`;
                el.classList.remove('opacity-0');
                setTimeout(() => { el.classList.add('opacity-0'); }, 1500);
            },

            winGame() {
                STATE.isPlaying = false;
                this.stopFireTimer();
                this.stopGameTimer();
                sound.playVictory();
                
                const elapsed = (Date.now() - STATE.gameStartTime) / 1000;
                let stars = 1;
                if (elapsed <= STATE.parTime) stars = 3;
                else if (elapsed <= STATE.parTime * 1.5) stars = 2;
                
                const timeStr = document.getElementById('game-timer').innerText;

                // SCORING LOGIC
                // 1. Calculate base level bonus score
                const levelBonusScore = Math.floor(Math.random() * 501) + 500;

                // 2. HIGH SCORE LOGIC: Accumulate the base score (persists across retries)
                STATE.cumulativeBaseScore += levelBonusScore; 

                // 3. STREAK LOGIC: Streak continues only on success
                STATE.streak++;
                const streakBonus = (STATE.streak - 1) * 100;

                // 4. CURRENT RUN SCORE: Total score for this successful run (including streak)
                STATE.currentRunScore += (levelBonusScore + streakBonus); 
                
                // 5. Check for New High Score (based on the base score accumulation)
                let isNewHighScore = false;
                if (STATE.cumulativeBaseScore > STATE.highScore) { 
                    STATE.highScore = STATE.cumulativeBaseScore;
                    isNewHighScore = true;
                    // Save the new high score using the persistent cumulativeBaseScore
                    saveProgress({ highScore: STATE.highScore }); 
                }
                
                this.showModal('win', {
                    level: STATE.level, 
                    time: timeStr, 
                    stars: stars,
                    levelBonus: levelBonusScore, 
                    currentScore: STATE.currentRunScore, // Display the full current run score
                    baseScore: STATE.cumulativeBaseScore, // Display the new high score source
                    isNewHighScore: isNewHighScore, 
                    streak: STATE.streak,
                    streakBonus: streakBonus,
                });
            },

            loseGame(reason) {
                STATE.isPlaying = false;
                this.stopFireTimer();
                this.stopGameTimer();
                
                if (reason.includes("Burned")) {
                    sound.playBurn();
                }

                // Reset the streak-dependent score and streak, but KEEP the cumulativeBaseScore
                STATE.currentRunScore = STATE.cumulativeBaseScore; // Score resets to accumulated base score
                STATE.streak = 0; // Streak ends
                
                this.showModal('lose', reason);
            },

            showModal(type, data) {
                const modal = document.getElementById('main-modal');
                const icon = document.getElementById('modal-icon');
                const title = document.getElementById('modal-title');
                const body = document.getElementById('modal-body');
                const btn = document.getElementById('modal-btn');
                const highScoreDisplay = document.getElementById('high-score-display'); 
                
                modal.classList.remove('hidden');
                highScoreDisplay.classList.add('hidden');

                if (type === 'welcome') {
                    icon.innerHTML = '<i class="fas fa-chess-knight text-cyan-500"></i><i class="fas fa-chess-king text-rose-500"></i>';
                    title.innerText = STATE.gameMode === 'math_tour' ? "Math Tour" : "Classic Tour";
                    body.innerHTML = STATE.gameMode === 'math_tour' 
                        ? "Collect enough score and capture the King."
                        : "Clear every tile and capture the King.";
                    btn.innerText = "Start Level 1";
                    btn.dataset.action = "start";
                    btn.classList.remove('hidden');
                    
                    highScoreDisplay.innerHTML = `HIGH SCORE: ${STATE.highScore.toLocaleString()}`;
                    highScoreDisplay.classList.remove('hidden'); 

                } else if (type === 'win') {
                    icon.innerHTML = '<i class="fas fa-crown text-yellow-400"></i>';
                    
                    let starHtml = '<div class="flex justify-center gap-2 mb-2 text-3xl">';
                    for(let i=1; i<=3; i++) {
                        if(i <= data.stars) starHtml += '<i class="fas fa-star text-yellow-400 star-pop" style="animation-delay: '+(i*0.1)+'s"></i>';
                        else starHtml += '<i class="far fa-star text-gray-600"></i>';
                    }
                    starHtml += '</div>';
                    
                    title.innerText = "Checkmate!";
                    
                    let bodyContent = `
                        ${starHtml}
                        Level ${data.level} Complete<br>
                        <span class="text-xl font-bold text-cyan-400">Time: ${data.time}</span>
                        <div class="mt-4 border-t border-slate-700 pt-3">
                            <p class="text-md text-gray-400">Level Bonus: <span class="text-lime-400 font-bold">+${data.levelBonus.toLocaleString()}</span></p>
                            ${data.streak > 1 ? `<p class="text-md text-gray-400">Streak x${data.streak} Bonus: <span class="text-yellow-400 font-bold">+${data.streakBonus.toLocaleString()}</span></p>` : ''}
                            <p class="text-xl font-bold text-yellow-300 mt-1">Total Score: ${data.currentScore.toLocaleString()}</p>
                        </div>
                    `;
                    if (data.isNewHighScore) {
                         bodyContent += `<p class="text-sm font-bold text-rose-500 mt-2">NEW HIGH SCORE! (Base: ${data.baseScore.toLocaleString()})</p>`;
                    }
                    body.innerHTML = bodyContent;
                    
                    btn.innerText = "Next Level";
                    btn.dataset.action = "next";
                    btn.classList.remove('hidden');
                } else if (type === 'lose') {
                    icon.innerHTML = '<i class="fas fa-skull text-gray-500"></i>';
                    title.innerText = "Defeat";
                    body.innerText = data;
                    btn.innerText = "Try Again";
                    btn.dataset.action = "retry";
                    btn.classList.remove('hidden');
                    
                    highScoreDisplay.innerHTML = `HIGH SCORE: ${STATE.highScore.toLocaleString()}`;
                    highScoreDisplay.classList.remove('hidden');
                }
            },

            hideModal() {
                document.getElementById('main-modal').classList.add('hidden');
            }
        };

        function toggleHelp() { 
            game.updateHelpModal();
            document.getElementById('help-modal').classList.toggle('hidden'); 
        }
        window.onload = () => game.init();

    </script>
</body>
</html>